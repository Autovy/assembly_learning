assume ds:data, es:table, cs:code
; 将data段的数据写入table中，并计算21年中的人均收入（取整）

; 数据段
; ----------------------------------------------------------------	
data segment

	db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
	db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
	db '1993','1994','1995'
	;以上是表示21年的21个字符串（地址从0-53H）
	
	dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
	dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
	;以上是表示21年公司总收入的21个 dword型数据（地址从54H-0A7H）
	
	
	dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
	dw 11542,14430,15257,17800
	;以上是表示21年公司雇员人数的21个word型数据（地址从0A8H-0D1H）
	
data ends


; 表格数据段
; ----------------------------------------------------------------	

table segment
	
	; 用dup为各列申请了空间
	db 21 dup ('year summ ne ??')
	
table ends



; 我们采用的策略是按行存储，只需要一个21次的循环即可完成任务
; ------------------------------------------------------------------
code segment
		
		; 定位data
start: 	mov ax, data
		mov ds, ax
		
		; 定位table
		mov ax, table
		mov es, ax
		
		; 设置寄存器
		; 设置循环寄存器，循环21次
		mov cx, 21
		
		; 用于指向数据段的数据（读取）
		mov bx, 0
		
		; 82即52H,因为读取完年份第一个数据后，地址为ds:2H
	    ; 所以要读到第一个年份对应的公司总收入，要加上si的82
		mov si, 82
		
		; 用于指向表格段数据（存储）
		mov bp, 0


; 循环读取数据按行存储
; ----------------------------------------------------------------	
		
		; 读取年份前半部分（16位），一个年份是32位的
	s: mov ax, ds:[bx]
		; 放入表格段中
		mov es:[bp], ax
		
		; 移动指针bx，bp，以存储年份后半部分
		add bx, 2
		add bp, 2
				
		; 读取年份后半部分
		mov ax, ds:[bx]
		mov es:[bp], ax
		

; 读取年份对应的年总收入		
; ----------------------------------------------------------------			
		; dd数据为32位，所以也要分两部分存储
		mov ax, ds:[bx + si]
		; 加上3是因为除了后半部分的年份还留有一个空格
		mov es:[bp + 3], ax
		
		mov ax, ds:[bx + si + 2]
		mov es:[bp + 3 + 2], ax



; 读取对应的公司雇员数据	
; ------------------------------------------------------------------		
		; 公司雇员数据都是16位的，直接一次性存完即可
		; 读完年总收入后，默认的地址为bx的值没有发生变化（即还指向年收入数据前半）
		; 所以对应雇员数据的地址应该是差54H即84
		mov ax, ds:[bx + si + 84]
		mov es:[bp + 3 + 2 + 3], ax
		


; 计算该年人均收入
; ---------------------------------------------------------------------
		; 取年总收入做被除数
		mov ax, ds:[bx + si]
		mov dx, ds:[bx + si + 2]
		
		; 取雇员人数数据做除数并运算，结果存在ax中
		div word ptr ds:[bx + si +84]
		
		; bp+11及bp + 3 + 2 + 3，
		mov es:[bp + 11], ax
		
		
; 循环结束前，移动地址为下次循环做准备
; ---------------------------------------------------------------------------
		; bx移动至下个年份的地址（读取地址）
		add bx, 2
		; bp移动至下个开始存储的地址,bp+14即bp + 3 + 2 + 3 + 3
		add bp, 14
		
		loop s
		
		
		mov ax, 4c00h
		int 21H




		
code ends

end start		
		
		
		
		
		
		